Задание
=======

1) Используя различные утилиты для анализа памяти виртуальной машины провести анализ работы программы из второго модуля.
Программа заявок.
2) Данные анализа описать в текстовом файле и добавить в репозиторий. В файле нужно указать,
каким инструментом проведен анализ и что по нему видно.
3) Попробовать добиться состояния выхода за пределы памяти и посмотреть состояние виртуальной машины.


Запуск StartUI - без пользовательского ввода ничего не происходит
=================================================================

Использование -verbose:gc при запуске
-------------------------------------
С параметром -verbose:gc при подключении VisualVM произошла только 1 сборка мусора за 7 минут:
[137,075s][info][gc] GC(0) Pause Young (Normal) (G1 Evacuation Pause) 24M->4M(252M) 11,524ms

Без подключении VisualVM ни одной сборки мусора не произошло за это же время.

Опция -XX:+PrintGCDetails дает слишком многословный вывод, который трудно интерпретировать без соответствующего знания.

Использование jstat
-------------------
jstat -gc <pid> <interval> <count>

 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   
 0,0    0,0    0,0    0,0   26624,0   5120,0   229376,0     0,0      0,0    0,0    0,0    0,0        0    0,000   0      0,000   0      0,000    0,000
 0,0    0,0    0,0    0,0   26624,0   7168,0   229376,0     0,0      0,0    0,0    0,0    0,0        0    0,000   0      0,000   0      0,000    0,000
Если никаких действий с программой не совершать, то состояние не меняется.
Если начать добавлять новые items, то происходит рост заполнения Eden Space.
Во 2-й строке видно увеличение использования Eden Space (столбец EU) с 5120,0 до 7168,0.

Если одновременно подключить VisualVM, то это вызовет сборки мусора (даже если не выполнять никаких действий),
которых не было без этого подключения.
На фрагменте данных ниже видно как растет Eden Usage (столбец EU) при подключении VisualVM.
Этого не происходит если использовать только консольный jstat.

 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   
 0,0   3072,0  0,0   3072,0 158720,0  7168,0   96256,0     1109,0   7680,0 6879,4 1024,0 768,6       1    0,014   0      0,000   0      0,000    0,014
 0,0   3072,0  0,0   3072,0 158720,0  8192,0   96256,0     1109,0   7680,0 6879,4 1024,0 768,6       1    0,014   0      0,000   0      0,000    0,014
 0,0   3072,0  0,0   3072,0 158720,0  8192,0   96256,0     1109,0   7680,0 6879,4 1024,0 768,6       1    0,014   0      0,000   0      0,000    0,014
 0,0   3072,0  0,0   3072,0 158720,0  9216,0   96256,0     1109,0   7680,0 6879,4 1024,0 768,6       1    0,014   0      0,000   0      0,000    0,014
 0,0   3072,0  0,0   3072,0 158720,0  9216,0   96256,0     1109,0   7680,0 6879,4 1024,0 768,6       1    0,014   0      0,000   0      0,000    0,014
 0,0   3072,0  0,0   3072,0 158720,0 10240,0   96256,0     1109,0   7680,0 6879,4 1024,0 768,6       1    0,014   0      0,000   0      0,000    0,014

Вывод: профайлер, такой как VisualVM может оказывать дополнительное воздействие на работу приложения.


Использование jmap
------------------
jmap -histo:live <pid> | head -n12

Вывод верхних по потреблению памяти 10 классов:
num     #instances         #bytes  class name (module)
   1:         12299        1333792  [B (java.base@11.0.7)
   2:         11586         278064  java.lang.String (java.base@11.0.7)
   3:          1446         177728  java.lang.Class (java.base@11.0.7)
   4:          4680         149760  java.util.HashMap$Node (java.base@11.0.7)
   5:          1638         140720  [Ljava.lang.Object; (java.base@11.0.7)
   6:           285         122736  [I (java.base@11.0.7)
   7:           378          59728  [Ljava.util.HashMap$Node; (java.base@11.0.7)
   8:            15          54288  [C (java.base@11.0.7)
   9:          1353          43296  java.util.concurrent.ConcurrentHashMap$Node (java.base@11.0.7)
  10:           634          25360  java.util.LinkedHashMap$Entry (java.base@11.0.7)

При этом по данным как из вывода в консоль приложения от опции -verbose:gc, так и по данным jstat, обнаружилось,
что каждый вызов jmap -histo:live приводит к дополнительному событию Full GC в приложении,
тогда как вызов jmap -histo (без live) этого не делает.


Использование Sampler в VisualVM
================================

Так как интерфейс StartUI данного приложения не дает простого способа автоматизированно нагрузить его скриптом
(помимо простого добавления items, для остальных действий нужен id объекта),
то для создания нагрузки был добавлен дополнительный класс ru.job4j.jmm.prof.TrackerLoader,
который производит сначала наполнение Tracker, потом замену сохраненных items.

Далее был использован Sampler в VisualVM.
Наполнение происходит мгновенно, основное время тратится на поиск и замену.
Ниже приводятся выборочные данные, по которым видно распределение нагрузки
между методами replace (20%) и findByName (80%)

Name                                                    Total Time          Total Time (CPU)
main	                                                32 097 ms (100 %)	32 097 ms (100 %)
    ru.job4j.jmm.prof.TrackerLoader.main ()	            32 097 ms (100 %)	32 097 ms (100 %)
        ru.job4j.jmm.prof.TrackerLoader.replaceItems ()	32 097 ms (100 %)	32 097 ms (100 %)
            ru.job4j.tracker.Tracker.findByName ()	    25 693 ms (80 %)	25 693 ms (80 %)
            ru.job4j.tracker.Tracker.replace ()	        6 404 ms (20 %)	    6 404 ms (20 %)


Нагрузка скриптом для получения java.lang.OutOfMemoryError
==========================================================

Для заполнения трекера используется скрипт ../sh/add-items.sh
На -Xmx32m приложение отрабатывает до конца, при уменьшении до -Xmx24m падает с OutOfMemoryError.
Пример запуска с добавлением 100000 объектов:
add-items.sh 100000 | java -Xmx24m ru.job4j.tracker.StartUI

Результат запуска jstat -gc <pid> 500:

S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT
 0,0   1024,0  0,0   1024,0  2048,0    0,0     21504,0    16965,9   5120,0 1168,7 512,0   83,6     251    0,262   0      0,000  158     0,074    0,335
 0,0   1024,0  0,0   1024,0  2048,0    0,0     21504,0    18051,6   5120,0 1168,7 512,0   83,6     287    0,288   0      0,000  180     0,083    0,371
 0,0   1024,0  0,0   1024,0  2048,0    0,0     21504,0    18742,4   5120,0 1168,7 512,0   83,6     324    0,314   0      0,000  200     0,091    0,405
 0,0    0,0    0,0    0,0    2048,0    0,0     22528,0    21734,3   5120,0 1168,7 512,0   83,6     361    0,338   1      0,000  222     0,100    0,439
 0,0   1024,0  0,0   1024,0  2048,0    0,0     21504,0    17750,5   5120,0 1168,7 512,0   83,6     398    0,358   1      0,025  242     0,108    0,491
 0,0   1024,0  0,0   1024,0  2048,0    0,0     21504,0    18261,4   5120,0 1168,7 512,0   83,6     433    0,382   2      0,049  262     0,115    0,546
 0,0    0,0    0,0    0,0    2048,0    0,0     22528,0    20750,9   5120,0 1168,7 512,0   83,6     461    0,401   9      0,201  272     0,119    0,720
 0,0    0,0    0,0    0,0    2048,0    0,0     22528,0    21145,6   5120,0 1168,7 512,0   83,6     485    0,415  21      0,509  272     0,119    1,042
 0,0    0,0    0,0    0,0    2048,0    0,0     22528,0    20500,2   5120,0 1168,7 512,0   83,6     507    0,431  32      0,835  272     0,119    1,384
 0,0    0,0    0,0    0,0    2048,0    0,0     22528,0    21887,7   5120,0 1168,7 512,0   83,6     530    0,445  45      1,132  272     0,119    1,696
 0,0    0,0    0,0    0,0    2048,0    0,0     22528,0    22202,0   5120,0 1168,7 512,0   83,6     549    0,460  59      1,486  272     0,119    2,065
 0,0    0,0    0,0    0,0    2048,0    0,0     22528,0    22450,0   5120,0 1168,7 512,0   83,6     564    0,476  74      1,865  272     0,119    2,459
 0,0    0,0    0,0    0,0    1024,0    0,0     23552,0    22681,2   5120,0 1168,7 512,0   83,6     578    0,491  88      2,243  272     0,119    2,852
 0,0    0,0    0,0    0,0    1024,0    0,0     23552,0    22912,6   5120,0 1168,7 512,0   83,6     592    0,504  102     2,644  272     0,119    3,267
 0,0    0,0    0,0    0,0    2048,0   1024,0   22528,0    22136,9   5120,0 1168,7 512,0   83,6     607    0,517  117     3,054  272     0,119    3,689
 0,0    0,0    0,0    0,0    8192,0    0,0      6144,0     1254,9   5120,0 1170,4 512,0   84,3     615    0,523  129     3,389  272     0,119    4,030

После добавления 97755-го объекта, программа падает с java.lang.OutOfMemoryError.
Приложение работает в режиме быстрого добавления новых объектов, поэтому когда хип заполняется,
оно не может продолжать работу.
На данных выше видно, что Old Space Capacity (OC) и Old Space Usage (OU) постепенно увеличивается,
только в последней строке резко падают, а Eden Space (EC) наоборот в конце стремится увеличится.
Если проанализировать частоту сборок (в этих данных только суммированное количество), то можно будет увидеть,
что (за исключением последней строки) частота сборок Young Gen (сумма в YGC) постепенно уменьшается,
а частота сборок Full GC (сумма в FGC) постепенно увеличивается, то есть происходит перераспределение ресурсов сборщика
так как Old Space все больше и больше заполняется добавляемыми объектами пережившими GC.
